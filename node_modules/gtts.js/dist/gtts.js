"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const fs = require("fs");
const util_1 = require("util");
const gttsToken_1 = require("./gttsToken");
const lang_1 = require("./lang");
const PreProcessors = require("./Tokenizer/PreProcessors");
const Tokenizer_1 = require("./Tokenizer/Tokenizer");
const TokenizerCases = require("./Tokenizer/TokenizerCases");
const utils_1 = require("./utils");
var Speed;
(function (Speed) {
    Speed[Speed["SLOW"] = 0.3] = "SLOW";
    Speed[Speed["NORMAL"] = 1] = "NORMAL";
})(Speed || (Speed = {}));
/**
 * gTTS -- Google Text-to-Speech.
 *
 * An interface to Google Translate's Text-to-Speech API.
 *
 * @export
 * @class gTTS
 */
// tslint:disable-next-line: class-name
class gTTS {
    // ...
    /**
     * Creates an instance of gTTS.
     *
     * @param {string} text
     * The text to be read.
     * @param {string} [lang]
     * The language (IETF language tag) to
     * read the text in. Defaults to 'en'.
     * @param {boolean} [slow]
     * Reads text more slowly. Defaults to `false`.
     * @param {boolean} [langCheck]
     * Strictly enforce an existing `lang`,
     * to catch a language error early. If set to `true`,
     * a `ValueError` is raised if `lang` doesn't exist.
     * Default is `true`.
     * @param {Array<(text: string) => string>} [preProcessorFuncs]
     * A list of zero or more functions that are
     * called to transform (pre-process) text before tokenizing. Those
     * functions must take a string and return a string. Defaults to:
     * ```
     *     [
     *         PreProcessors.toneMarks,
     *         PreProcessors.endOfLine,
     *         PreProcessors.abbreviations,
     *         PreProcessors.wordSub,
     *     ]
     * ```
     * @param {(text: string) => string[]} [tokenizerFunc]
     * A function that takes in a string and
     * returns a list of string (tokens). Defaults to:
     * ```
     *     Tokenizer([
     *         tokenizer_cases.tone_marks,
     *         tokenizer_cases.period_comma,
     *         tokenizer_cases.colon,
     *         tokenizer_cases.other_punctuation
     *     ]).run
     * ```
     * @memberof gTTS
     */
    constructor(text, lang = "en", slow = false, langCheck = true, preProcessorFuncs = [
        PreProcessors.toneMarks,
        PreProcessors.endOfLine,
        PreProcessors.abbreviations,
        PreProcessors.wordSub,
    ], tokenizerFunc = new Tokenizer_1.Tokenizer([
        TokenizerCases.toneMarks,
        TokenizerCases.periodComma,
        TokenizerCases.colon,
        TokenizerCases.otherPunctuation,
    ]).run) {
        // TODO: Debug
        // CONSTANTS
        this.GOOGLE_TTS_MAX_CHARS = 100; // Max characters the Google TTS API takes at a time
        this.GOOGLE_TTS_URL = "https://translate.google.com/translate_tts";
        this.GOOGLE_TTS_HEADERS = {
            "Referer": "http://translate.google.com/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64)  " +
                "AppleWebKit/537.36 (KHTML, like Gecko) " +
                "Chrome/47.0.2526.106 Safari/537.36",
        };
        // Text
        if (!text) {
            throw new Error("No text to speak");
        }
        this.text = text;
        // Language (async)
        this.lang = lang;
        this.langList = langCheck ? lang_1.ttsLangs() : null;
        //  Read speed
        if (slow) {
            this.speed = Speed.SLOW;
        }
        else {
            this.speed = Speed.NORMAL;
        }
        // Pre-processors and tokenizer
        this.preProcessorFuncs = preProcessorFuncs;
        this.tokenizerFunc = tokenizerFunc;
        // Google Translate token (async)
        this.token = new gttsToken_1.Token();
    }
    save(savefile) {
        return this.process(savefile);
    }
    /**
     * Do the TTS API request and write bytes to a file-like object.
     *
     * @private
     * @param {string} savefile file path to write the `mp3` to.
     * @memberof gTTS
     */
    process(savefile) {
        return __awaiter(this, void 0, void 0, function* () {
            // Check language
            if (this.langList !== null) {
                const langs = Object.keys(yield this.langList).map((el) => el.toLowerCase());
                if (!langs.includes(this.lang.toLowerCase())) {
                    throw new Error(`Language not supported: ${this.lang}`);
                }
            }
            // Open file for write access
            const fsOpen = util_1.promisify(fs.open);
            const fsWrite = util_1.promisify(fs.write);
            let file;
            try {
                file = yield fsOpen(savefile, "w");
            }
            catch (err) {
                throw new Error(`Error while accessing file: ${err.message}`);
            }
            // Token
            const textParts = this.tokenize(this.text);
            if (!textParts) {
                throw new Error("No text to send to TTS API");
            }
            for (const [idx, part] of textParts.entries()) {
                yield this.token.calculateToken(part)
                    .catch((err) => {
                    throw new Error(`Connection error during token calculation: ${err.message}`);
                })
                    .then((partToken) => {
                    const payload = {
                        client: "tw-ob",
                        idx,
                        ie: "UTF-8",
                        q: part,
                        textlen: part.length,
                        tk: partToken,
                        tl: this.lang,
                        total: textParts.length,
                        ttsspeed: this.speed,
                    };
                    return Promise.resolve(payload);
                })
                    .then((payload) => {
                    return axios_1.default.get(this.GOOGLE_TTS_URL, {
                        headers: this.GOOGLE_TTS_HEADERS,
                        params: payload,
                        responseType: "arraybuffer",
                    });
                })
                    .catch((err) => {
                    throw new Error(`Request failed: ${err.message}`);
                })
                    .then((response) => {
                    if (response.status === 403) {
                        throw new Error(`Bad token or upstream API changes`);
                    }
                    else if (response.status === 404 && this.langList === null) {
                        throw new Error(`Unsupported language: ${this.lang}`);
                    }
                    else if (response.status >= 500) {
                        throw new Error(`Uptream API error. Try again later`);
                    }
                    return Promise.resolve(response.data);
                })
                    .then((buffer) => {
                    return fsWrite(file, buffer);
                })
                    .catch((err) => {
                    throw new Error(`Error writing the file: ${err.message}`);
                })
                    .then((value) => {
                    return Promise.resolve();
                });
            }
        });
    }
    tokenize(text) {
        // Pre-clean
        text = text.trim();
        // Apply pre-processors
        for (const pp of this.preProcessorFuncs) {
            text = pp(text);
        }
        if (text.length <= this.GOOGLE_TTS_MAX_CHARS) {
            return utils_1.cleanTokens([text]);
        }
        // Tokenize
        let tokens = this.tokenizerFunc(text);
        // Clean
        tokens = utils_1.cleanTokens(tokens);
        // Minimize
        let minTokens = [];
        for (const t of tokens) {
            minTokens = [...minTokens, ...utils_1.minimize(t, " ", this.GOOGLE_TTS_MAX_CHARS)];
        }
        return minTokens;
    }
}
exports.gTTS = gTTS;
