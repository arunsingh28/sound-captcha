"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PreProcessorRegex_1 = require("./PreProcessorRegex");
const PreProcessorSub_1 = require("./PreProcessorSub");
const Symbols = require("./Symbols");
/**
 * Add a space after tone-modifying punctuation.
 *
 * Because the `toneMarks` tokenizer case will split after a tone-modidfying
 * punctuation mark, make sure there's whitespace after.
 *
 * @export
 * @param {string} text
 * @returns {string}
 */
function toneMarks(text) {
    return new PreProcessorRegex_1.PreProcessorRegex(Symbols.TONE_MARKS, (x) => `(?<=${x})`, " ").run(text);
}
exports.toneMarks = toneMarks;
/**
 * Re-form words cut by end-of-line hyphens.
 *
 * Remove "<hyphen><newline>".
 *
 * @export
 * @param {string} text
 * @returns {string}
 */
function endOfLine(text) {
    return new PreProcessorRegex_1.PreProcessorRegex("-", (x) => `${x}\n`, "").run(text);
}
exports.endOfLine = endOfLine;
/**
 * Remove periods after an abbreviation from a list of known
 * abbrevations that can be spoken the same without that period. This
 * prevents having to handle tokenization of that period.
 *
 * Note:
 *     Could potentially remove the ending period of a sentence.
 * Note:
 *     Abbreviations that Google Translate can't pronounce without
 *     (or even with) a period should be added as a word substitution with a
 *     :class:`PreProcessorSub` pre-processor. Ex.: 'Esq.', 'Esquire'.
 *
 * @export
 * @param {string} text
 * @returns {string}
 */
function abbreviations(text) {
    return new PreProcessorRegex_1.PreProcessorRegex(Symbols.ABBREVIATIONS, (x) => `(?<=${x})(?=\.).`, "", "i").run(text);
}
exports.abbreviations = abbreviations;
/**
 * Word-for-word substitutions.
 *
 * @export
 * @param {string} text
 * @returns {string}
 */
function wordSub(text) {
    return new PreProcessorSub_1.PreProcessorSub(Symbols.SUB_PAIRS).run(text);
}
exports.wordSub = wordSub;
