"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RegexBuilder_1 = require("./RegexBuilder");
const Symbols = require("./Symbols");
/**
 * Keep tone-modifying punctuation by matching following character.
 *
 * Assumes the `tone_marks` pre-processor was run for cases where there might
 * not be any space after a tone-modifying punctuation mark.
 *
 * @export
 * @returns {RegExp}
 */
function toneMarks() {
    return new RegexBuilder_1.RegexBuilder(Symbols.TONE_MARKS, (x) => `(?<=${x}).`).regex;
}
exports.toneMarks = toneMarks;
/**
 * Period and comma case.
 *
 * Match if not preceded by ".<letter>" and only if followed by space.
 * Won't cut in the middle/after dotted abbreviations; won't cut numbers.
 *
 * Note:
 *     Won't match if a dotted abbreviation ends a sentence.
 * Note:
 *     Won't match the end of a sentence if not followed by a space.
 *
 * @export
 * @returns {RegExp}
 */
function periodComma() {
    return new RegexBuilder_1.RegexBuilder(Symbols.PERIOD_COMMA, (x) => `(?<!\.[a-z])${x} `).regex;
}
exports.periodComma = periodComma;
/**
 * Colon case.
 *
 * Match a colon ":" only if not preceeded by a digit.
 * Mainly to prevent a cut in the middle of time notations e.g. 10:01
 *
 * @export
 * @returns {RegExp}
 */
function colon() {
    return new RegexBuilder_1.RegexBuilder(Symbols.COLON, (x) => `(?<!\d)${x}`).regex;
}
exports.colon = colon;
/**
 * Match other punctuation.
 *
 * Match other punctuation to split on; punctuation that naturally
 * inserts a break in speech.
 *
 * @export
 * @returns {RegExp}
 */
function otherPunctuation() {
    const punc = Array.from(new Set([
        ...Symbols.ALL_PUNC,
        ...Symbols.TONE_MARKS,
        ...Symbols.PERIOD_COMMA,
        ...Symbols.COLON,
    ])).join("");
    return new RegexBuilder_1.RegexBuilder(punc, (x) => `${x.normalize()}`).regex;
}
exports.otherPunctuation = otherPunctuation;
/**
 * Match all punctuation.
 *
 * Use as only tokenizer case to mimic gTTS 1.x tokenization.
 *
 * @export
 * @returns {RegExp}
 */
function legacyAllPunctuation() {
    const punc = Symbols.ALL_PUNC;
    return new RegexBuilder_1.RegexBuilder(punc, (x) => `${x.normalize()}`).regex;
}
exports.legacyAllPunctuation = legacyAllPunctuation;
